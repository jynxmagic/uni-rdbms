---          ###TITLE MIGRATION###                   --- 
---  here, columns are updated individually using    ---
---  the pk. there is duplicate data and we don't    ---
---  want to ovveride correct values with null.      ---

---drop existing data
DELETE FROM title;

--- insert title_ids, skip duplicates.
--- refs: https://richardfoote.wordpress.com/2010/12/20/oracle11g-ignore_row_on_dupkey_index-hint-micro-cuts/
--- 10/03/2020
INSERT /*+ ignore_row_on_dupkey_index(title(title_id)) */ INTO TITLE(TITLE_ID)
    SELECT TITLE_ID
    FROM OLD_TITLES;
COMMIT;


---update columns
---refs: https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9016.htm#SQLRF01606
---10/03/2020
---title---
MERGE INTO title n
USING (SELECT DISTINCT title_id,
                title 
      FROM old_titles WHERE TITLE IS NOT NULL      
      ) o
ON(n.title_id=o.title_id)
WHEN MATCHED THEN
    UPDATE SET n.title = o.title;
    COMMIT;
---released----
MERGE INTO title n
USING (SELECT DISTINCT title_id, released
        FROM old_titles WHERE released IS NOT NULL) o
ON(n.title_id = o.title_id)        
WHEN MATCHED THEN
    UPDATE SET n.released = o.released;
    COMMIT;
---runtime----
MERGE INTO title n
USING (SELECT DISTINCT TITLE_ID, RUNTIME
        FROM OLD_TITLES WHERE RUNTIME IS NOT NULL) o
ON(n.title_id = o.title_id)
WHEN MATCHED THEN
    UPDATE SET n.runtime = o.runtime;
    COMMIT;

--counts to verify data---
SELECT COUNT(*) AS "NULL TITLES" FROM TITLE WHERE TITLE IS NULL;
SELECT COUNT(*) AS "NULL RELEASED" FROM TITLE WHERE RELEASED IS NULL;
SELECT COUNT(TITLE_ID) AS "NULL RUNTIMES" FROM TITLE WHERE RUNTIME IS NULL; --- 600 rows null :(. needs verification


---          ###NAMES MIGRATION###                   --- 
--- same process as title. ignore dupe keys then     ---
--- update the data with the duplicate inputs        ---


--drop existing data
DELETE FROM PERSON;

--insert pks
INSERT /*+ ignore_row_on_dupkey_index(person(person_id)) */ INTO PERSON(PERSON_ID)
    SELECT NAME_ID
    FROM OLD_NAMES;
COMMIT;
--update columns
--name
MERGE INTO PERSON P
USING (SELECT DISTINCT NAME_ID, NAME FROM OLD_NAMES WHERE NAME IS NOT NULL) O
ON(P.PERSON_ID=O.NAME_ID)
WHEN MATCHED THEN 
    UPDATE SET P.NAME = O.NAME;
    COMMIT;
--birth year
MERGE INTO PERSON P
USING (SELECT DISTINCT NAME_ID, BIRTHYEAR FROM OLD_NAMES WHERE BIRTHYEAR IS NOT NULL) O
ON(P.PERSON_ID = O.NAME_ID)
WHEN MATCHED THEN
    UPDATE SET P.BIRTH_YEAR = O.BIRTHYEAR;
    COMMIT;
--death year
MERGE INTO PERSON P
USING(SELECT DISTINCT NAME_ID, DEATHYEAR FROM OLD_NAMES WHERE DEATHYEAR IS NOT NULL) O
ON(P.PERSON_ID=O.NAME_ID)
WHEN MATCHED THEN
    UPDATE SET P.DEATH_YEAR=O.DEATHYEAR;
    COMMIT;

SELECT NAME AS "GUY WE DON`T LIKE" FROM PERSON WHERE LENGTH(NAME) > 35 ; -- we don't like this guy

SELECT COUNT(*) AS "NULL NAMES" FROM PERSON WHERE NAME IS NULL;
SELECT COUNT(PERSON_ID) AS "NULL BIRTH YEARS" FROM PERSON WHERE BIRTH_YEAR IS NULL;
SELECT COUNT(PERSON_ID) AS "NULL DEATH YEARS" FROM PERSON WHERE DEATH_YEAR IS NULL; -- lots of nulls.

---          ###PROFESSION MIGRATION###                 --- 

--CLEAR TABLE
DELETE FROM PROFESSION;

INSERT INTO PROFESSION(PROFESSION)
    SELECT DISTINCT PROFESSION1 from old_names where profession1 is not null 
    UNION 
        select PROFESSION2 
        from old_names  
        where profession2 is not null 
    UNION 
        select PROFESSION3 
        FROM OLD_NAMES 
        where profession3 is not null ;
COMMIT;

---          ###PERSON PROFESSION MIGRATION###           ---

--DELETE DATA
DELETE FROM PERSON_PROFESSION;

---profession
INSERT INTO PERSON_PROFESSION(PERSON_ID, PROFESSION_ID)
    SELECT NAME_ID, O.PROFESSION1
    FROM OLD_NAMES O
    WHERE O.PROFESSION1 IS NOT NULL
    AND O.PROFESSION1 IN (SELECT PROFESSION FROM PROFESSION)
    union 
        SELECT NAME_ID, O.PROFESSION2
        FROM OLD_NAMES O
        WHERE O.PROFESSION2 IS NOT NULL
        AND O.PROFESSION2 IN (SELECT PROFESSION FROM PROFESSION)
    union 
        SELECT NAME_ID, O.PROFESSION3
        FROM OLD_NAMES O
        WHERE O.PROFESSION3 IS NOT NULL
        AND O.PROFESSION3 IN (SELECT PROFESSION FROM PROFESSION);
COMMIT;
--verify, show ppl and amnt of professions they have
SELECT DISTINCT PERSON_ID AS "PERSON", COUNT(PROFESSION_ID) AS "# OF PROFESSIONS" FROM PERSON_PROFESSION GROUP BY PERSON_ID ORDER BY COUNT(PROFESSION_ID) desc FETCH FIRST 200 ROWS ONLY;


---          ###PERSON TITLEs  MIGRATION###             ---

--delete data
DELETE FROM PERSON_TITLE;

--knownfortitles
INSERT INTO /*+ ignore_row_on_dupkey_index(person_title(person_id, title_id)) */ PERSON_TITLE(PERSON_ID,TITLE_ID)
    SELECT O.NAME_ID, O.KNOWNFORTITLES1
    FROM OLD_NAMES O
    WHERE KNOWNFORTITLES1 IS NOT NULL
    union 
        SELECT O.NAME_ID, O.KNOWNFORTITLES2
        FROM OLD_NAMES O
        WHERE KNOWNFORTITLES2 IS NOT NULL
    union
        SELECT O.NAME_ID, O.KNOWNFORTITLES3
        FROM OLD_NAMES O
        WHERE KNOWNFORTITLES3 IS NOT NULL
    union
        SELECT O.NAME_ID, O.KNOWNFORTITLES4
        FROM OLD_NAMES O
        WHERE KNOWNFORTITLES4 IS NOT NULL; -- see comment after inserts
COMMIT;

-- SOME TITLES DON'T EXISTS. REMOVED FOREIGN KEY CONSTRAINT TO INSERT ---
--- CODE USED TO CHECK
---SELECT COUNT(TITLE_ID) FROM OLD_TITLES WHERE TITLE_ID NOT IN (SELECT TITLE_ID FROM TITLE);
---SELECT COUNT(KNOWNFORTITLES1) FROM OLD_NAMES WHERE KNOWNFORTITLES1 NOT IN (SELECT TITLE_ID FROM TITLE);
--SELECT KNOWNFORTITLES1 FROM OLD_NAMES WHERE KNOWNFORTITLES1 NOT IN (SELECT TITLE_ID FROM TITLE);
---SELECT * FROM OLD_TITLES 
--WHERE OLD_TITLES.TITLE_ID = 'tt0061055';
---SELECT COUNT(TITLE_ID) FROM TITLE;
--IT APPEARS SOME TITLES WHERE DELETED AFTER "KNOWNFORTITLES" COLUMN WAS UPDATED. THERE'S A NAME FOR THIS


--verification
SELECT DISTINCT PERSON_ID, COUNT(TITLE_ID) AS "# OF TITLES" FROM PERSON_TITLE GROUP BY PERSON_ID ORDER BY COUNT(TITLE_ID) DESC FETCH FIRST 200 ROWS ONLY;
SELECT * FROM OLD_NAMES WHERE NAME_ID = 'nm0089294';
--ya das ist gut


---          ###DIRECTOR  MIGRATION###            ---
--clear current data
DELETE FROM DIRECTOR;

--director
INSERT INTO DIRECTOR(DIRECTOR)
    SELECT DISTINCT director1
    FROM OLD_TITLES
    WHERE director1 IS NOT NULL
    AND DIRECTOR1 IN (SELECT PERSON_ID FROM PERSON)
    union
        SELECT DIRECTOR2
        FROM OLD_TITLES
        WHERE DIRECTOR2 IS NOT NULL
        AND DIRECTOR2 IN (SELECT PERSON_ID FROM PERSON)
    union
        SELECT DIRECTOR3
        FROM OLD_TITLES
        WHERE DIRECTOR3 IS NOT NULL
        AND DIRECTOR3 IN (SELECT PERSON_ID FROM PERSON)
    union
        SELECT DIRECTOR4
        FROM OLD_TITLES
        WHERE DIRECTOR4 IS NOT NULL
        AND DIRECTOR4 IN(SELECT PERSON_ID FROM PERSON);
COMMIT;



--verification
SELECT COUNT(director.DIRECTOR) AS "# of directors"
FROM DIRECTOR;

SELECT COUNT(person.person_id) "# OF PEOPLE"
FROM PERSON;

---          ###genre  MIGRATION###            ---

--clear current data
DELETE FROM GENRE;

INSERT INTO GENRE(GENRE)
    SELECT DISTINCT GENRE1
    FROM OLD_TITLES
    WHERE GENRE1 IS NOT NULL
    union
        SELECT DISTINCT GENRE2
        FROM OLD_TITLES
        WHERE GENRE2 IS NOT NULL
    union
        SELECT DISTINCT GENRE3
        FROM OLD_TITLES
        WHERE GENRE3 IS NOT NULL;
COMMIT;


SELECT GENRE FROM GENRE;

---          ###WRITER  MIGRATION###            ---

--clear data
DELETE FROM WRITER;

INSERT INTO WRITER(PERSON_ID)
    SELECT DISTINCT WRITER1
    FROM OLD_TITLES
    WHERE WRITER1 IS NOT NULL
    AND WRITER1 IN (SELECT PERSON_ID FROM PERSON);
COMMIT;

INSERT INTO WRITER(PERSON_ID)
    SELECT DISTINCT WRITER2
    FROM OLD_TITLES
    WHERE WRITER2 IS NOT NULL
    AND WRITER2 IN (SELECT PERSON_ID FROM PERSON)
    AND WRITER2 NOT IN (SELECT PERSON_ID FROM WRITER);
COMMIT;

INSERT INTO WRITER(PERSON_ID)
    SELECT DISTINCT WRITER3
    FROM OLD_TITLES
    WHERE WRITER3 IS NOT NULL
    AND WRITER3 IN (SELECT PERSON_ID FROM PERSON)
    AND WRITER3 NOT IN (SELECT PERSON_ID FROM WRITER);
COMMIT;

INSERT INTO WRITER(PERSON_ID)
    SELECT DISTINCT WRITER4
    FROM OLD_TITLES
    WHERE WRITER4 IS NOT NULL
    AND WRITER4 IN (SELECT PERSON_ID FROM PERSON)
    AND WRITER4 NOT IN (SELECT PERSON_ID FROM WRITER);
COMMIT;

INSERT INTO WRITER(PERSON_ID)
    SELECT DISTINCT WRITER5
    FROM OLD_TITLES
    WHERE WRITER5 IS NOT NULL
    AND WRITER5 IN (SELECT PERSON_ID FROM PERSON)
    AND WRITER5 NOT IN (SELECT PERSON_ID FROM WRITER);
COMMIT;

---          ###JOB_CATEGORY  MIGRATION###            ---
DELETE FROM JOB_CATEGORY;

INSERT INTO JOB_CATEGORY(JOB_CATEGORY)
    SELECT DISTINCT JOB_CATEGORY
    FROM OLD_TITLES
    WHERE JOB_CATEGORY IS NOT NULL;
COMMIT;    

---          ###PRINCIPAL  MIGRATION###            ---
DELETE FROM PRINCIPAL;

INSERT INTO PRINCIPAL(PERSON_ID)
    SELECT DISTINCT PRINCIPAL
    FROM OLD_TITLES
    WHERE PRINCIPAL IS NOT NULL
    AND PRINCIPAL IN (SELECT PERSON_ID FROM PERSON);
COMMIT;

---          ###CHARACTER  MIGRATION###            ---
DELETE FROM CHARACTER;


--this is made from many different sites
--the last site used is referenced here
--ref: https://stackoverflow.com/questions/14328621/splitting-string-into-multiple-rows-in-oracle#comment103966436_14331055
--description: create a temp table to hold data. then, remove quotes from the value. then, use the regular exp substring function to delete any data after ";". finally, create a heirarchial structure using the connect by experssion with the "level" pseduocolumn
--note: i don't know what this means
--p.s this takes a while
--11/03/2020

--TODO
---INSERT /*+ ignore_row_on_dupkey_index(CHARACTER(CHARACTER)) */ INTO CHARACTER(CHARACTER)
 ---       SELECT regexp_substr(CHARACTERS_PLAYED, '[^;]+', 1, LEVEL) CP
  ---      FROM OLD_TITLES
 ---       WHERE CHARACTERS_PLAYED IS NOT NULL
 --       CONNECT BY  regexp_substr(CHARACTERS_PLAYED, '[^;]+', 1, LEVEL) IS NOT NULL;
--COMMIT;



---          ###TITLE_DIRECTOR  MIGRATION###        ---
DELETE FROM TITLE_DIRECTOR;


INSERT INTO TITLE_DIRECTOR(TITLE_ID, DIRECTOR_ID)
    SELECT TITLE_ID, DIRECTOR1
    FROM old_titles
    WHERE TITLE_ID IS NOT NULL
    AND DIRECTOR1 IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND DIRECTOR1 IN (SELECT DIRECTOR FROM DIRECTOR);
COMMIT;

INSERT INTO TITLE_DIRECTOR(TITLE_ID, DIRECTOR_ID)
    SELECT TITLE_ID, DIRECTOR2
    FROM old_titles
    WHERE TITLE_ID IS NOT NULL
    AND DIRECTOR2 IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND DIRECTOR2 IN (SELECT DIRECTOR FROM DIRECTOR);
COMMIT;

INSERT INTO TITLE_DIRECTOR(TITLE_ID, DIRECTOR_ID)
    SELECT TITLE_ID, DIRECTOR3
    FROM old_titles
    WHERE TITLE_ID IS NOT NULL
    AND DIRECTOR3 IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND DIRECTOR3 IN (SELECT DIRECTOR FROM DIRECTOR);
COMMIT;

INSERT INTO TITLE_DIRECTOR(TITLE_ID, DIRECTOR_ID)
    SELECT TITLE_ID, DIRECTOR4
    FROM old_titles
    WHERE TITLE_ID IS NOT NULL
    AND DIRECTOR4 IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND DIRECTOR4 IN (SELECT DIRECTOR FROM DIRECTOR);
COMMIT;


--verification
select count(director_id) AS "# OF TIMES DIRECTORS ARE ATTACHED TO FILMS (?)" FROM title_director;

---          ###TITLE_GENRE  MIGRATION###        ---

DELETE FROM TITLE_GENRE;

INSERT INTO TITLE_GENRE (TITLE_ID, GENRE_ID)
    SELECT TITLE_ID, GENRE1
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND GENRE1 IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND GENRE1 IN (SELECT GENRE FROM GENRE);
COMMIT;

INSERT INTO TITLE_GENRE (TITLE_ID, GENRE_ID)
    SELECT TITLE_ID, GENRE2
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND GENRE2 IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND GENRE2 IN (SELECT GENRE FROM GENRE);
COMMIT;

INSERT INTO TITLE_GENRE (TITLE_ID, GENRE_ID)
    SELECT TITLE_ID, GENRE3
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND GENRE3 IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND GENRE3 IN (SELECT GENRE FROM GENRE);
COMMIT;


--verification
SELECT COUNT(GENRE_ID) AS "# OF FILMS IN THIS GENRE", GENRE_ID FROM TITLE_GENRE GROUP BY GENRE_ID;


---          ###TITLE_JOB_CATEGORY  MIGRATION###        ---
DELETE FROM title_job_category;

INSERT INTO TITLE_JOB_CATEGORY(title_id, JOB_CATEGORY_ID)
    SELECT TITLE_ID, JOB_CATEGORY
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND JOB_CATEGORY IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND JOB_CATEGORY IN (SELECT JOB_CATEGORY FROM JOB_CATEGORY);
COMMIT;

--verification
SELECT COUNT(JOB_CATEGORY_ID) AS "# OF JOBS", JOB_CATEGORY_ID JOB_CATEOGRY FROM TITLE_JOB_CATEGORY GROUP BY job_category_id;


---          ###TITLE_PRINCIPAL  MIGRATION###        ---
DELETE FROM TITLE_PRINCIPAL;

INSERT INTO TITLE_PRINCIPAL(TITLE_ID, PRINCIPAL_ID)
    SELECT TITLE_ID, PRINCIPAL
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND PRINCIPAL IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE)
    AND PRINCIPAL IN (SELECT PERSON_ID FROM PRINCIPAL);
COMMIT;

--verification
SELECT * FROM TITLE_PRINCIPAL FETCH FIRST 200 ROWS ONLY;



---          ###RATING  MIGRATION###        ---
DELETE FROM TITLE_RATING;

--title rating
INSERT INTO TITLE_RATING(TITLE_ID, AVERAGE_RATING)
    SELECT DISTINCT TITLE_ID, AVERAGERATING
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND AVERAGERATING IS NOT NULL
    AND TITLE_ID IN (SELECT TITLE_ID FROM TITLE);
COMMIT;

DELETE FROM rating_votes;

--rating votes
INSERT INTO RATING_VOTES(RATING_ID, NUMVOTES)
    SELECT DISTINCT TITLE_RATING.RATING_ID, OLD_TITLES.NUMVOTES
    FROM TITLE_RATING
    LEFT OUTER JOIN OLD_TITLES
    ON TITLE_RATING.TITLE_ID = OLD_TITLES.TITLE_ID;
COMMIT;


--TEST CODE FOR STUFFS
--SELECT * FROM TITLE_RATING T LEFT JOIN OLD_TITLES O ON T.TITLE_ID = O.TITLE_ID;
--SELECT * FROM OLD_TITLES WHERE TITLE_ID = 'tt0102520';


--verification
SELECT TITLE.TITLE, TITLE_RATING.AVERAGE_RATING, RATING_VOTES.NUMVOTES
FROM TITLE 
INNER JOIN TITLE_RATING  ON TITLE.TITLE_ID = TITLE_RATING.TITLE_ID 
INNER JOIN RATING_VOTES  ON TITLE_RATING.RATING_ID = RATING_VOTES.RATING_ID
ORDER BY title_rating.average_rating DESC,rating_votes.numvotes DESC
FETCH FIRST 200 ROWS ONLY; --noice
--verification2 (lol)
SELECT TITLE.TITLE, TITLE_RATING.AVERAGE_RATING, RATING_VOTES.NUMVOTES
FROM TITLE 
INNER JOIN TITLE_RATING  ON TITLE.TITLE_ID = TITLE_RATING.TITLE_ID 
INNER JOIN RATING_VOTES  ON TITLE_RATING.RATING_ID = RATING_VOTES.RATING_ID
WHERE TITLE.TITLE IS NULL
OR  TITLE_RATING.AVERAGE_RATING IS NULL
OR RATING_VOTES.NUMVOTES IS NULL; --noice2

---          ###TITLE_WRITER MIGRATION###        ---
DELETE FROM TITLE_WRITER;

INSERT INTO TITLE_WRITER(TITLE_ID, WRITER_ID)
    SELECT DISTINCT TITLE_ID, WRITER1
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND WRITER1 IS NOT NULL;
COMMIT;

INSERT INTO TITLE_WRITER
    SELECT DISTINCT TITLE_ID, WRITER2
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND WRITER2 IS NOT NULL;
COMMIT;

INSERT INTO TITLE_WRITER
    SELECT DISTINCT TITLE_ID, WRITER3
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND WRITER3 IS NOT NULL;
COMMIT;

INSERT INTO TITLE_WRITER
    SELECT DISTINCT TITLE_ID, WRITER4
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND WRITER4 IS NOT NULL;
COMMIT;

INSERT INTO TITLE_WRITER
    SELECT DISTINCT TITLE_ID, WRITER5
    FROM OLD_TITLES
    WHERE TITLE_ID IS NOT NULL
    AND WRITER5 IS NOT NULL;
COMMIT;

SELECT TITLE_ID, COUNT(DISTINCT WRITER_ID) AS "# OF RECORDED WRITERS" FROM TITLE_WRITER GROUP BY title_id ORDER BY COUNT(DISTINCT WRITER_ID) DESC FETCH FIRST 150 ROWS ONLY;


-- finished, but how much did it cost?